//===-- llvm/DC/DCInstruction.h - Instruction Translation -------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines DCInstruction, the main interface that can be used to
// translate machine code instructions (represented by an MCDecodedInst) to IR.
//
// DCInstruction provides various methods - some provided by a Target-specific
// subclassing implementation - that translate instruction-level MC constructs
// into a corresponding sequence of IR instructions (possibly creating control
// flow).
//
//===----------------------------------------------------------------------===//


#ifndef LLVM_DC_DCINSTRUCTION_H
#define LLVM_DC_DCINSTRUCTION_H

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/CodeGen/ValueTypes.h"
#include "llvm/DC/DCBasicBlock.h"
#include "llvm/DC/DCOpcodes.h"
#include "llvm/DC/DCRegisterSema.h"
#include "llvm/MC/MCAnalysis/MCFunction.h"
#include "llvm/Support/ErrorHandling.h"

namespace llvm {

class DCInstruction {
protected:
  DCBasicBlock &DCB;
  const MCDecodedInst &TheMCInst;

  typedef IRBuilder<NoFolder> DCIRBuilder;
  DCIRBuilder Builder;

  // translation vars.
  unsigned SemaIdx;
  Type *ResTy;
  SmallVector<Value *, 16> Vals;

  // Autogenerated by tblgen
  const unsigned *OpcodeToSemaIdx;
  const unsigned *SemanticsArray;
  const uint64_t *ConstantArray;

public:
  DCInstruction(DCBasicBlock &DCB, const MCDecodedInst &MCI,
                const unsigned *OpcodeToSemaIdx, const unsigned *SemanticsArray,
                const uint64_t *ConstantArray);
  virtual ~DCInstruction();

  bool translate();

  DCRegisterSema &getDRS() { return getParent().getDRS(); }
  LLVMContext &getContext() { return getParent().getContext(); }
  Module *getModule() { return getParent().getModule(); }
  Function *getFunction() { return getParent().getFunction(); }

  DCBasicBlock &getParent() { return DCB; }

  unsigned Next() { return SemanticsArray[SemaIdx++]; }
  Type *NextTy();

  Value *getNextOperand() {
    unsigned OpIdx = Next();
    assert(OpIdx < Vals.size() && "Trying to access non-existent operand");
    return Vals[OpIdx];
  }

  void registerResult(Value *ResV) { Vals.push_back(ResV); }

  uint64_t getImmOp(unsigned Idx) {
    return TheMCInst.Inst.getOperand(Idx).getImm();
  }
  unsigned getRegOp(unsigned Idx) {
    return TheMCInst.Inst.getOperand(Idx).getReg();
  }

  Value *getReg(unsigned RegNo) { return getDRS().getReg(RegNo); }
  void setReg(unsigned RegNo, Value *Val) { getDRS().setReg(RegNo, Val); }

  void insertCall(Value *CallTarget);

  bool translateOpcode(unsigned Opcode);

  virtual bool translateTargetOpcode(unsigned Opcode) = 0;
  virtual Value *translateCustomOperand(unsigned OperandType,
                                        unsigned MIOperandNo) = 0;
  virtual bool translateImplicit(unsigned RegNo) = 0;

  virtual Value *translateComplexPattern(unsigned Pattern);
  virtual bool translatePredicate(unsigned Pred);

  /// Try to do a custom translation of a full instruction.
  /// Called before translating an instruction.
  /// Return true if the translation shouldn't proceed.
  /// The \p InstOpcode can be modified by the implementation to proceed with
  /// the translation as if that was the currently translated instruction.
  virtual bool translateTargetInst(unsigned &InstOpcode) { return false; }

private:
  bool tryTranslateInst();

  void translateBinOp(Instruction::BinaryOps Opc);
  void translateCastOp(Instruction::CastOps Opc);

  bool translateExtLoad(Type *MemTy, bool isSExt = false);
};

} // end namespace llvm

#endif
